<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Room v1</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1212; overflow: hidden; }
  canvas { display: block; }
  #loading {
    position: fixed; inset: 0; background: #fff;
    z-index: 10; transition: opacity 1.2s ease;
  }
  #loading.fade { opacity: 0; pointer-events: none; }
  #overlay {
    position: fixed; inset: 0;
    display: flex; align-items: center; justify-content: center;
    background: rgba(0,0,0,0.55); z-index: 5; cursor: pointer;
  }
  #overlay.hidden { display: none; }
  #overlay-box {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.18);
    padding: 36px 56px; text-align: center; color: #fff;
    font: 13px/2.2 system-ui, sans-serif;
    backdrop-filter: blur(10px); border-radius: 6px;
  }
  #overlay-box h2 { font-size: 20px; font-weight: 400; margin-bottom: 6px; letter-spacing: 0.03em; }
  #overlay-box p  { opacity: 0.5; font-size: 11px; letter-spacing: 0.06em; text-transform: uppercase; }
  #crosshair {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none; display: none;
  }
  #crosshair::before, #crosshair::after {
    content: ''; position: absolute; background: rgba(255,255,255,0.75);
  }
  #crosshair::before { width: 14px; height: 1px; top: 0; left: -7px; }
  #crosshair::after  { width: 1px; height: 14px; top: -7px; left: 0; }
</style>
<script src="https://cdn.ably.com/lib/ably.min-2.js"></script>
<script src="https://unpkg.com/gifler@0.1.0/gifler.min.js"></script>
</head>
<body>

<div id="loading"></div>
<div id="overlay">
  <div id="overlay-box">
    <h2>Click to explore</h2>
    <p>WASD · move &nbsp;|&nbsp; Mouse · look &nbsp;|&nbsp; E / Q · up / down &nbsp;|&nbsp; ESC · exit</p>
  </div>
</div>
<div id="crosshair"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// ─── Renderer ────────────────────────────────────────────────────────────────
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

// ─── Scene ───────────────────────────────────────────────────────────────────
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf5efe6);

// ─── Camera ──────────────────────────────────────────────────────────────────
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.001, 300);

// ─── FPS Controls ────────────────────────────────────────────────────────────
const controls = new PointerLockControls(camera, document.body);
scene.add(controls.getObject());

const overlay   = document.getElementById('overlay');
const crosshair = document.getElementById('crosshair');

overlay.addEventListener('click', () => controls.lock());

controls.addEventListener('lock', () => {
  overlay.classList.add('hidden');
  crosshair.style.display = 'block';
});
controls.addEventListener('unlock', () => {
  overlay.classList.remove('hidden');
  crosshair.style.display = 'none';
});

// ─── WASD ────────────────────────────────────────────────────────────────────
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; });
window.addEventListener('keyup',   e => { keys[e.code] = false; });

const vel = { fwd: 0, right: 0, up: 0 };
const MAX_SPEED = 0.55;   // units/sec — lower = slower
const ACCEL     = 5.0;    // how fast velocity ramps up/down (higher = snappier)

function updateMovement(dt) {
  if (!controls.isLocked) return;

  const tFwd   = (keys['KeyW'] || keys['ArrowUp'])    ?  MAX_SPEED
               : (keys['KeyS'] || keys['ArrowDown'])  ? -MAX_SPEED : 0;
  const tRight = (keys['KeyD'] || keys['ArrowRight']) ?  MAX_SPEED
               : (keys['KeyA'] || keys['ArrowLeft'])  ? -MAX_SPEED : 0;
  const tUp    = (keys['KeyE'] || keys['Space'])       ?  MAX_SPEED
               : (keys['KeyQ'] || keys['ShiftLeft'])   ? -MAX_SPEED : 0;

  // Lerp velocity toward target — gives smooth acceleration & deceleration
  const t = Math.min(ACCEL * dt, 1);
  vel.fwd   += (tFwd   - vel.fwd)   * t;
  vel.right += (tRight - vel.right) * t;
  vel.up    += (tUp    - vel.up)    * t;

  controls.moveForward(vel.fwd   * dt);
  controls.moveRight(vel.right   * dt);
  camera.position.y += vel.up    * dt;
}

// ─── Load GLB ────────────────────────────────────────────────────────────────
const loading = document.getElementById('loading');

new GLTFLoader().load('room_segmented.glb', (gltf) => {
  const root = gltf.scene;
  const box  = new THREE.Box3().setFromObject(root);
  const center = box.getCenter(new THREE.Vector3());
  const size   = box.getSize(new THREE.Vector3());
  root.position.sub(center);

  // Start inside, roughly at eye height
  camera.position.set(0, size.y * 0.05, 0);

  root.traverse((child) => {
    if (!(child instanceof THREE.Mesh)) return;

    // MeshBasicMaterial — vertex colors only, no lighting = no distant blackout
    child.material = new THREE.MeshBasicMaterial({
      vertexColors: true,
      side: THREE.DoubleSide,
    });

    // Thin wireframe edge overlay
    const edges = new THREE.EdgesGeometry(child.geometry, 15);
    child.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({
      color: 0x2a2520, transparent: true, opacity: 0.35, depthTest: true,
    })));
  });

  scene.add(root);
  loading.classList.add('fade');
  setTimeout(() => loading.style.display = 'none', 1300);
});

// ─── Resize ──────────────────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ─── Multiplayer (Ably) ──────────────────────────────────────────────────────
const ABLY_KEY    = '3_kKZA.xluPKw:KAwWxBzjQ2yb_LryDly-32d4ziQpLDwZKerNJAecybc';
const AVATAR_SCALE = 0.08;  // small — world units
const MY_ID       = Math.random().toString(36).slice(2, 8);
const MY_AVATAR   = Math.floor(Math.random() * 10);  // random avatar on load
const peers       = new Map();   // id → sprite
let   ablyChannel = null;
let   lastSend    = 0;

const AVATAR_URLS = [
  'avatars/avatar0.gif',
  'avatars/avatar1.gif',
  'avatars/avatar2.gif',
  'avatars/avatar3.gif',
  'avatars/avatar4.gif',
  'avatars/avatar5.gif',
  'avatars/avatar6.gif',
  'avatars/avatar7.gif',
  'avatars/avatar8.gif',
  'avatars/avatar9.gif',
];

// Animated GIF textures via gifler — fetches GIF, drives frame timing itself
const avatarTextures = [];

AVATAR_URLS.forEach(url => {
  const canvas = document.createElement('canvas');
  const tex = new THREE.CanvasTexture(canvas);
  tex.colorSpace = THREE.SRGBColorSpace;
  avatarTextures.push(tex);

  // gifler fetches the GIF, parses frames, calls back with each frame
  gifler(url).frames(canvas, (ctx, frame) => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(frame.buffer, 0, 0);
    tex.needsUpdate = true;  // tell Three.js to upload the new frame to GPU
  });
});

function updateAvatarTextures() { /* gifler drives updates via its own timer */ }

function addPeer(id, avatarIdx = 0) {
  if (peers.has(id) || id === MY_ID) return;
  const tex    = avatarTextures[avatarIdx % avatarTextures.length];
  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
    map: tex, transparent: true, depthTest: true,
  }));
  sprite.scale.set(AVATAR_SCALE, AVATAR_SCALE, 1);
  scene.add(sprite);
  peers.set(id, sprite);
}

function removePeer(id) {
  const s = peers.get(id);
  if (s) { scene.remove(s); peers.delete(id); }
}

function movePeer(id, x, y, z, avatarIdx) {
  if (id === MY_ID) return;
  if (!peers.has(id)) addPeer(id, avatarIdx);
  const s = peers.get(id);
  if (s) s.position.set(x, y, z);
}

function publishPosition() {
  if (!ablyChannel || !controls.isLocked) return;
  const now = performance.now();
  if (now - lastSend < 80) return;
  lastSend = now;
  ablyChannel.publish('move', {
    id: MY_ID, av: MY_AVATAR,
    x: camera.position.x, y: camera.position.y, z: camera.position.z,
  });
}

(function initAbly() {
  const ably = new Ably.Realtime({ key: ABLY_KEY, clientId: MY_ID });
  ablyChannel = ably.channels.get('room-presence');
  ablyChannel.subscribe('move', msg => {
    const d = msg.data;
    movePeer(d.id, d.x, d.y, d.z, d.av ?? 0);
  });
  ablyChannel.presence.subscribe('enter',  m => addPeer(m.clientId, m.data?.av ?? 0));
  ablyChannel.presence.subscribe('leave',  m => removePeer(m.clientId));
  ablyChannel.presence.subscribe('absent', m => removePeer(m.clientId));
  ablyChannel.presence.get((err, members) => {
    if (!err) members.forEach(m => {
      if (m.clientId !== MY_ID) addPeer(m.clientId, m.data?.av ?? 0);
    });
  });
  ablyChannel.presence.enter({ av: MY_AVATAR });
})();

// ─── Render loop ─────────────────────────────────────────────────────────────
let last = performance.now();
function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt  = Math.min((now - last) / 1000, 0.05);
  last = now;
  updateMovement(dt);
  publishPosition();
  updateAvatarTextures();
  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
