<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Room v1</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1212; overflow: hidden; }
  canvas { display: block; }
  #loading {
    position: fixed; inset: 0; background: #fff;
    z-index: 10; transition: opacity 1.2s ease;
  }
  #loading.fade { opacity: 0; pointer-events: none; }
  #overlay {
    position: fixed; inset: 0;
    display: flex; align-items: center; justify-content: center;
    background: rgba(0,0,0,0.55); z-index: 5; cursor: pointer;
  }
  #overlay.hidden { display: none; }
  #overlay-box {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.18);
    padding: 36px 56px; text-align: center; color: #fff;
    font: 13px/2.2 system-ui, sans-serif;
    backdrop-filter: blur(10px); border-radius: 6px;
  }
  #overlay-box h2 { font-size: 20px; font-weight: 400; margin-bottom: 6px; }
  #overlay-box p  { opacity: 0.5; font-size: 11px; letter-spacing: 0.06em; text-transform: uppercase; }
  #crosshair { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); pointer-events: none; display: none; }
  #crosshair::before, #crosshair::after { content:''; position:absolute; background:rgba(255,255,255,0.75); }
  #crosshair::before { width:14px; height:1px; top:0; left:-7px; }
  #crosshair::after  { width:1px; height:14px; top:-7px; left:0; }
  /* My own avatar preview — bottom left, confirms GIFs are working */
  #my-avatar {
    position: fixed; bottom: 16px; left: 16px;
    width: 48px; height: 48px;
    border-radius: 4px; z-index: 20;
    image-rendering: pixelated;
    opacity: 0.85;
  }
</style>
</head>
<body>
<div id="loading"></div>
<div id="overlay">
  <div id="overlay-box">
    <h2>Click to explore</h2>
    <p>WASD · move &nbsp;|&nbsp; Mouse · look &nbsp;|&nbsp; E / Q · up / down &nbsp;|&nbsp; ESC · exit</p>
  </div>
</div>
<div id="crosshair"></div>
<!-- Your own avatar shown bottom-left so you can verify GIFs work -->
<img id="my-avatar" src="" alt="">

<script type="importmap">
{
  "imports": {
    "three":         "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
    "ably":          "https://esm.sh/ably@2"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
import { GLTFLoader }          from 'three/addons/loaders/GLTFLoader.js';
import Ably                    from 'ably';

// ─── Renderer ────────────────────────────────────────────────────────────────
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

// ─── Scene / Camera ──────────────────────────────────────────────────────────
const scene  = new THREE.Scene();
scene.background = new THREE.Color(0xf5efe6);
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.001, 300);

// ─── FPS Controls ────────────────────────────────────────────────────────────
const controls = new PointerLockControls(camera, document.body);
scene.add(controls.getObject());
const overlay   = document.getElementById('overlay');
const crosshair = document.getElementById('crosshair');
overlay.addEventListener('click', () => controls.lock());
controls.addEventListener('lock',   () => { overlay.classList.add('hidden');    crosshair.style.display = 'block'; });
controls.addEventListener('unlock', () => { overlay.classList.remove('hidden'); crosshair.style.display = 'none';  });

// ─── WASD ────────────────────────────────────────────────────────────────────
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; });
window.addEventListener('keyup',   e => { keys[e.code] = false; });
const vel = { fwd: 0, right: 0, up: 0 };
const MAX_SPEED = 0.55, ACCEL = 5.0;
function updateMovement(dt) {
  if (!controls.isLocked) return;
  const tF = keys['KeyW']||keys['ArrowUp']    ?  MAX_SPEED : keys['KeyS']||keys['ArrowDown']  ? -MAX_SPEED : 0;
  const tR = keys['KeyD']||keys['ArrowRight'] ?  MAX_SPEED : keys['KeyA']||keys['ArrowLeft']  ? -MAX_SPEED : 0;
  const tU = keys['KeyE']||keys['Space']       ?  MAX_SPEED : keys['KeyQ']||keys['ShiftLeft']  ? -MAX_SPEED : 0;
  const t = Math.min(ACCEL * dt, 1);
  vel.fwd   += (tF - vel.fwd)   * t;
  vel.right += (tR - vel.right) * t;
  vel.up    += (tU - vel.up)    * t;
  controls.moveForward(vel.fwd   * dt);
  controls.moveRight(vel.right   * dt);
  camera.position.y += vel.up * dt;
}

// ─── Load room ───────────────────────────────────────────────────────────────
const loading = document.getElementById('loading');
new GLTFLoader().load('room_segmented.glb', (gltf) => {
  const root = gltf.scene;
  const box  = new THREE.Box3().setFromObject(root);
  root.position.sub(box.getCenter(new THREE.Vector3()));
  camera.position.set(0, box.getSize(new THREE.Vector3()).y * 0.05, 0);
  root.traverse(c => {
    if (!(c instanceof THREE.Mesh)) return;
    c.material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide });
    c.add(new THREE.LineSegments(
      new THREE.EdgesGeometry(c.geometry, 15),
      new THREE.LineBasicMaterial({ color: 0x2a2520, transparent: true, opacity: 0.35 })
    ));
  });
  scene.add(root);
  loading.classList.add('fade');
  setTimeout(() => loading.style.display = 'none', 1300);
});

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ─── Animated GIF textures (ImageDecoder API) ─────────────────────────────
// Falls back to static img for unsupported browsers (Safari)
const AVATAR_URLS = Array.from({ length: 10 }, (_, i) => `avatars/avatar${i}.gif`);
const texCache    = new Map();   // key → THREE.CanvasTexture

async function loadGIF(key) {
  if (texCache.has(key)) return texCache.get(key);

  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 128;
  const tex = new THREE.CanvasTexture(canvas);
  tex.colorSpace = THREE.SRGBColorSpace;
  texCache.set(key, tex);   // store immediately so duplicate calls don't double-load

  const url = AVATAR_URLS[key % AVATAR_URLS.length];

  try {
    const blob = await fetch(url).then(r => r.blob());

    if (typeof ImageDecoder !== 'undefined') {
      // ── Native frame-accurate GIF animation ──────────────────────────────
      const decoder = new ImageDecoder({ data: blob.stream(), type: 'image/gif' });
      await decoder.tracks.ready;
      const frameCount = decoder.tracks.selectedTrack.frameCount;
      let fi = 0;

      const ctx = canvas.getContext('2d');
      async function nextFrame() {
        try {
          const { image } = await decoder.decode({ frameIndex: fi % frameCount });
          if (canvas.width !== image.displayWidth)  canvas.width  = image.displayWidth;
          if (canvas.height !== image.displayHeight) canvas.height = image.displayHeight;
          ctx.drawImage(image, 0, 0);
          const delay = (image.duration ?? 100000) / 1000;  // microseconds → ms
          image.close();
          tex.needsUpdate = true;
          fi++;
          setTimeout(nextFrame, Math.max(delay, 20));
        } catch { fi = 0; setTimeout(nextFrame, 100); }
      }
      nextFrame();

    } else {
      // ── Fallback: blob URL img (static first frame in Safari) ─────────────
      const src = URL.createObjectURL(blob);
      const img = new Image();
      img.src = src;
      await new Promise(r => img.onload = r);
      canvas.getContext('2d').drawImage(img, 0, 0, 128, 128);
      tex.needsUpdate = true;
    }
  } catch (e) { console.warn('Avatar load failed', key, e); }

  return tex;
}

// ─── Multiplayer ─────────────────────────────────────────────────────────────
const ABLY_KEY     = '3_kKZA.xluPKw:KAwWxBzjQ2yb_LryDly-32d4ziQpLDwZKerNJAecybc';
const AVATAR_SCALE = 0.08;
const MY_ID        = Math.random().toString(36).slice(2, 8);
const MY_AVATAR    = Math.floor(Math.random() * 10);
const peers        = new Map();
let   ablyChannel  = null, lastSend = 0;

// Show your own avatar in the corner
document.getElementById('my-avatar').src = AVATAR_URLS[MY_AVATAR];

async function addPeer(id, av = 0) {
  if (peers.has(id) || id === MY_ID) return;
  const mat    = new THREE.SpriteMaterial({ transparent: true, depthTest: true });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(AVATAR_SCALE, AVATAR_SCALE, 1);
  scene.add(sprite);
  peers.set(id, sprite);
  const tex = await loadGIF(av % AVATAR_URLS.length);
  mat.map = tex; mat.needsUpdate = true;
}
function removePeer(id) { const s = peers.get(id); if (s) { scene.remove(s); peers.delete(id); } }
function movePeer(id, x, y, z, av) {
  if (id === MY_ID) return;
  if (!peers.has(id)) addPeer(id, av);
  const s = peers.get(id); if (s) s.position.set(x, y, z);
}
function publishPos() {
  if (!ablyChannel || !controls.isLocked) return;
  const now = performance.now(); if (now - lastSend < 80) return; lastSend = now;
  ablyChannel.publish('move', { id: MY_ID, av: MY_AVATAR,
    x: camera.position.x, y: camera.position.y, z: camera.position.z });
}

try {
  const ably = new Ably.Realtime({ key: ABLY_KEY, clientId: MY_ID });
  ablyChannel = ably.channels.get('room-presence');
  ablyChannel.subscribe('move', msg => { const d = msg.data; movePeer(d.id, d.x, d.y, d.z, d.av ?? 0); });
  ablyChannel.presence.subscribe('enter',  m => addPeer(m.clientId, m.data?.av ?? 0));
  ablyChannel.presence.subscribe('leave',  m => removePeer(m.clientId));
  ablyChannel.presence.subscribe('absent', m => removePeer(m.clientId));
  ablyChannel.presence.get((e, ms) => { if (!e) ms.forEach(m => { if (m.clientId !== MY_ID) addPeer(m.clientId, m.data?.av ?? 0); }); });
  ablyChannel.presence.enter({ av: MY_AVATAR });
} catch (e) { console.warn('Ably:', e); }

// ─── Render loop ─────────────────────────────────────────────────────────────
let last = performance.now();
function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt  = Math.min((now - last) / 1000, 0.05); last = now;
  updateMovement(dt);
  publishPos();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
