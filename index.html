<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Room v1</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1212; overflow: hidden; }
  canvas { display: block; }
  #loading {
    position: fixed; inset: 0; background: #fff;
    z-index: 10; transition: opacity 1.2s ease;
  }
  #loading.fade { opacity: 0; pointer-events: none; }
  #overlay {
    position: fixed; inset: 0;
    display: flex; align-items: center; justify-content: center;
    background: rgba(0,0,0,0.55); z-index: 5; cursor: pointer;
  }
  #overlay.hidden { display: none; }
  #overlay-box {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.18);
    padding: 36px 56px; text-align: center; color: #fff;
    font: 13px/2.2 system-ui, sans-serif;
    backdrop-filter: blur(10px); border-radius: 6px;
  }
  #overlay-box h2 { font-size: 20px; font-weight: 400; margin-bottom: 6px; }
  #overlay-box p  { opacity: 0.5; font-size: 11px; letter-spacing: 0.06em; text-transform: uppercase; }
  #crosshair { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); pointer-events: none; display: none; }
  #crosshair::before, #crosshair::after { content:''; position:absolute; background:rgba(255,255,255,0.75); }
  #crosshair::before { width:14px; height:1px; top:0; left:-7px; }
  #crosshair::after  { width:1px; height:14px; top:-7px; left:0; }
  /* My own avatar preview — bottom left, confirms GIFs are working */
  #my-avatar {
    position: fixed; bottom: 16px; left: 16px;
    width: 48px; height: 48px;
    border-radius: 4px; z-index: 20;
    image-rendering: pixelated;
    opacity: 0.85;
    object-fit: contain;
  }
</style>
</head>
<body>
<div id="loading"></div>
<div id="overlay">
  <div id="overlay-box">
    <h2>Click to explore</h2>
    <p>WASD · move &nbsp;|&nbsp; Mouse · look &nbsp;|&nbsp; E / Q · up / down &nbsp;|&nbsp; ESC · exit</p>
  </div>
</div>
<div id="crosshair"></div>
<!-- Your own avatar shown bottom-left so you can verify GIFs work -->
<img id="my-avatar" src="" alt="">

<script type="importmap">
{
  "imports": {
    "three":         "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
    "ably":          "https://esm.sh/ably@2"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
import { GLTFLoader }          from 'three/addons/loaders/GLTFLoader.js';
// Ably loaded dynamically below — keeps scene alive if CDN is slow/unreachable

// ─── Renderer ────────────────────────────────────────────────────────────────
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

// ─── Scene / Camera ──────────────────────────────────────────────────────────
const scene  = new THREE.Scene();
scene.background = new THREE.Color(0xf5efe6);
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.001, 300);

// ─── FPS Controls ────────────────────────────────────────────────────────────
const controls = new PointerLockControls(camera, document.body);
scene.add(controls.getObject());
const overlay   = document.getElementById('overlay');
const crosshair = document.getElementById('crosshair');
overlay.addEventListener('click', () => controls.lock());
controls.addEventListener('lock',   () => { overlay.classList.add('hidden');    crosshair.style.display = 'block'; });
controls.addEventListener('unlock', () => { overlay.classList.remove('hidden'); crosshair.style.display = 'none';  });

// ─── WASD ────────────────────────────────────────────────────────────────────
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; });
window.addEventListener('keyup',   e => { keys[e.code] = false; });
const vel = { fwd: 0, right: 0, up: 0 };
const MAX_SPEED = 0.55, ACCEL = 5.0;
function updateMovement(dt) {
  if (!controls.isLocked) return;
  const tF = keys['KeyW']||keys['ArrowUp']    ?  MAX_SPEED : keys['KeyS']||keys['ArrowDown']  ? -MAX_SPEED : 0;
  const tR = keys['KeyD']||keys['ArrowRight'] ?  MAX_SPEED : keys['KeyA']||keys['ArrowLeft']  ? -MAX_SPEED : 0;
  const tU = keys['KeyE']||keys['Space']       ?  MAX_SPEED : keys['KeyQ']||keys['ShiftLeft']  ? -MAX_SPEED : 0;
  const t = Math.min(ACCEL * dt, 1);
  vel.fwd   += (tF - vel.fwd)   * t;
  vel.right += (tR - vel.right) * t;
  vel.up    += (tU - vel.up)    * t;
  controls.moveForward(vel.fwd   * dt);
  controls.moveRight(vel.right   * dt);
  camera.position.y += vel.up * dt;
}

// ─── Load room ───────────────────────────────────────────────────────────────
const loading = document.getElementById('loading');
new GLTFLoader().load('room_segmented.glb', (gltf) => {
  const root = gltf.scene;
  const box  = new THREE.Box3().setFromObject(root);
  root.position.sub(box.getCenter(new THREE.Vector3()));
  camera.position.set(0, box.getSize(new THREE.Vector3()).y * 0.05, 0);
  root.traverse(c => {
    if (!(c instanceof THREE.Mesh)) return;
    c.material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide });
    c.add(new THREE.LineSegments(
      new THREE.EdgesGeometry(c.geometry, 15),
      new THREE.LineBasicMaterial({ color: 0x2a2520, transparent: true, opacity: 0.35 })
    ));
  });
  scene.add(root);
  loading.classList.add('fade');
  setTimeout(() => loading.style.display = 'none', 1300);
});

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ─── Animated GIF textures (ImageDecoder) ────────────────────────────────
// ImageDecoder API: Chrome/Firefox/Edge native — decodes all frames upfront,
// then drives playback via the main rAF loop (no setTimeout = no silent stops).
// Safari fallback: static first frame.
const AVATAR_URLS = Array.from({ length: 10 }, (_, i) => `avatars/avatar${i}.gif`);
const texCache    = new Map();   // key → THREE.CanvasTexture
const gifAnims    = [];          // { frames, delays, idx, nextMs, ctx, tex }

async function loadGIF(key) {
  if (texCache.has(key)) return texCache.get(key);

  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 128;
  const ctx = canvas.getContext('2d');
  const tex = new THREE.CanvasTexture(canvas);
  tex.colorSpace = THREE.SRGBColorSpace;
  texCache.set(key, tex);

  const url = AVATAR_URLS[key % AVATAR_URLS.length];
  try {
    const buffer = await fetch(url).then(r => r.arrayBuffer());

    if (typeof ImageDecoder !== 'undefined') {
      // Decode every frame into ImageBitmaps upfront
      const decoder = new ImageDecoder({ data: buffer, type: 'image/gif' });
      await decoder.tracks.ready;
      const frames = [], delays = [];
      for (let fi = 0; ; fi++) {
        try {
          const { image } = await decoder.decode({ frameIndex: fi });
          delays.push(Math.max((image.duration ?? 100000) / 1000, 20)); // µs → ms
          frames.push(await createImageBitmap(image));
          image.close();
        } catch { break; }
      }
      if (!frames.length) throw new Error('no frames');
      canvas.width  = frames[0].width;
      canvas.height = frames[0].height;
      ctx.drawImage(frames[0], 0, 0);
      tex.needsUpdate = true;
      // Register with rAF-driven loop — no setTimeout chain to break
      gifAnims.push({ frames, delays, idx: 0, nextMs: performance.now() + delays[0], ctx, tex });
    } else {
      // Safari: static first frame via blob URL
      const blob = URL.createObjectURL(new Blob([buffer], { type: 'image/gif' }));
      const img  = Object.assign(new Image(), { src: blob });
      await new Promise(r => { img.onload = r; img.onerror = r; });
      canvas.width  = img.naturalWidth  || 128;
      canvas.height = img.naturalHeight || 128;
      ctx.drawImage(img, 0, 0);
      tex.needsUpdate = true;
    }
  } catch (e) { console.warn('Avatar GIF failed', key, e); }

  return tex;
}

// Called from animate() — advances any GIF that's due for a new frame
function tickGIFs(nowMs) {
  for (const anim of gifAnims) {
    if (nowMs < anim.nextMs) continue;
    anim.idx = (anim.idx + 1) % anim.frames.length;
    const bmp   = anim.frames[anim.idx];
    const delay = anim.delays[anim.idx];
    anim.ctx.clearRect(0, 0, anim.ctx.canvas.width, anim.ctx.canvas.height);
    anim.ctx.drawImage(bmp, 0, 0);
    anim.tex.needsUpdate = true;
    anim.nextMs = nowMs + delay;
  }
}

// ─── Multiplayer ─────────────────────────────────────────────────────────────
const ABLY_KEY     = '3_kKZA.xluPKw:KAwWxBzjQ2yb_LryDly-32d4ziQpLDwZKerNJAecybc';
const AVATAR_SCALE = 0.08;
const MY_ID        = Math.random().toString(36).slice(2, 8);
const MY_AVATAR    = Math.floor(Math.random() * 10);
const peers        = new Map();
let   ablyChannel  = null, lastSend = 0;

// Show your own avatar in the corner
document.getElementById('my-avatar').src = AVATAR_URLS[MY_AVATAR];

async function addPeer(id, av = 0) {
  if (peers.has(id) || id === MY_ID) return;
  const mat    = new THREE.SpriteMaterial({ transparent: true, depthTest: true });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(AVATAR_SCALE, AVATAR_SCALE, 1);
  scene.add(sprite);
  peers.set(id, sprite);
  const tex = await loadGIF(av % AVATAR_URLS.length);
  mat.map = tex; mat.needsUpdate = true;
}
function removePeer(id) { const s = peers.get(id); if (s) { scene.remove(s); peers.delete(id); } }
function movePeer(id, x, y, z, av) {
  if (id === MY_ID) return;
  if (!peers.has(id)) addPeer(id, av);
  const s = peers.get(id); if (s) s.position.set(x, y, z);
}
function publishPos() {
  if (!ablyChannel || !controls.isLocked) return;
  const now = performance.now(); if (now - lastSend < 80) return; lastSend = now;
  ablyChannel.publish('move', { id: MY_ID, av: MY_AVATAR,
    x: camera.position.x, y: camera.position.y, z: camera.position.z });
}

// Dynamic Ably import — scene runs fine even if this fails
import('ably').then(mod => {
  const Ably = mod.default;
  try {
    const ably = new Ably.Realtime({ key: ABLY_KEY, clientId: MY_ID });
    ablyChannel = ably.channels.get('room-presence');
    ablyChannel.subscribe('move', msg => { const d = msg.data; movePeer(d.id, d.x, d.y, d.z, d.av ?? 0); });
    ablyChannel.presence.subscribe('enter',  m => addPeer(m.clientId, m.data?.av ?? 0));
    ablyChannel.presence.subscribe('leave',  m => removePeer(m.clientId));
    ablyChannel.presence.subscribe('absent', m => removePeer(m.clientId));
    ablyChannel.presence.get((e, ms) => { if (!e) ms.forEach(m => { if (m.clientId !== MY_ID) addPeer(m.clientId, m.data?.av ?? 0); }); });
    ablyChannel.presence.enter({ av: MY_AVATAR });
  } catch (e) { console.warn('Ably init:', e); }
}).catch(e => console.warn('Ably CDN failed (multiplayer disabled):', e));

// ─── Render loop ─────────────────────────────────────────────────────────────
let last = performance.now();
function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt  = Math.min((now - last) / 1000, 0.05); last = now;
  updateMovement(dt);
  publishPos();
  tickGIFs(now); // rAF-driven GIF playback (now is already ms from performance.now)
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
